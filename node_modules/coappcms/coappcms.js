// Since I can't write in coffee-script, I created this in javascript, and 
// just pass the work along to it.

var querystring = require("querystring");
var md5 = require('MD5');
var http = require('http');
var util= require('util');
var enumerabl=require("enumerable"); 
var spawn = require('child_process').spawn;
var ejs= require("ejs");
var gfm = require("github-flavored-markdown");
var fs = require('fs');
var path = require('path');

var cms= {};

if (typeof exports === "object") {
    cms = exports;
    cms.config = null;
    cms.highlightCache = {};
/*        
    cms.markdownCache = {};
    cms.last_urls = [];
    cms.last_titles = [];         
*/        
    cms.g_urls = [];
    cms.g_titles = [];     
    cms.imgs = [".jpg", ".gif", ".png", ".JPG", ".GIF", ".PNG" ].enumerable();
        
    cms.setConfig = function( config ) {
        cms.config = config;
    }
    
    /// Our cms.include function acts as a <>.html.md.ejs filter.
    cms.include = function(file, templateData) {
        file = path.join( cms.config.includePath , file );
        if( path.existsSync(file) ) {
            var filecontent = fs.readFileSync(file,encoding='utf8');
            filecontent = ejs.render(filecontent, templateData);
            return cms.markdown(filecontent, templateData);
        }
        return "INCLUDE FAIL: ["+file+"] does not exist";
    };
    
    cms.markdown = function( filecontent, templateData ) {
        /* still thinking.
        var hash = md5(filecontent);
        if( undefined != cms.markdownCache[hash] ) {
            return cms.markdownCache[hash];
        }
        */ 
        
        
        // handle my custom anchors
        // [text](!id)
        if( templateData != undefined &&  templateData.document != undefined && templateData.document.docid != undefined ) {
            var match = null;
            var rx = /\[(.*?)\]\(\!(.*?)\)/g;
            var x =0;
            while( (match = rx.exec(filecontent) ) != null ) {
                // match[2]
                cms.g_urls[templateData.document.docid + "#" +match[2]] = templateData.document.url + "#" +match[2];
                cms.g_titles[templateData.document.docid + "#" +match[2]] = match[1] +" in " + templateData.document.title;
            }
        }
        filecontent = filecontent.replace(/\[(.*?)\]\(\!(.*?)\)/gi , '<a id="$2" href="#$2">$1</a>' );
        
        // handle my custom image inserts
        // @[text](url)
        filecontent = filecontent.replace(/@\[(.*?)\]\((.*?)\)/gi , function(m0,m1,m2) {
            return '<span class="scrollcontainer">!['+m1+']('+((cms.g_urls[m2] == undefined) ? m2 : cms.g_urls[m2]) +')</span>';
        } );
        
        // handle my custom video inserts
        // %[width,height,posterimageurl,mp4url,webmurl]
        filecontent = filecontent.replace(/%\[\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*\]/gi, function(p0,p1,p2,p3,p4,p5) {
            return '\n<div class="embeddedvideo">\n<video width="100%" height="100%" poster="'+((cms.g_urls[p3] == undefined) ? p3 : cms.g_urls[p3])+'" controls="controls" preload="none" style="width:100%; height:100%;">' +
            '    <source type="video/mp4" src="'+p4+'" />' +
            '    <source type="video/webm" src="'+p5+'" />' +         
            '    <object width="'+p1+'" height="'+p2+'" type="application/x-shockwave-flash" data="/scripts/flashmediaelement.swf">' + 
            '        <param name="movie" value="/scripts/flashmediaelement.swf" />' +
            '        <param name="flashvars" value="controls=true&file='+p4+'" />' + 
            '        <img src="'+((cms.g_urls[p3] == undefined) ? p3 : cms.g_urls[p3])+'" width="'+p1+'" height="'+p2+'" title="No video playback capabilities" />' + //Image as a last resort 
            '    </object>'+ 
            '</video>\n</div>\n'
        });
        
        filecontent = gfm.parse( filecontent, undefined, cms.g_urls, cms.g_titles );
        
        // return cms.markdownCache[hash] = filecontent.replace(/ /ig, "");
        return filecontent.replace(/ /ig, "");
    }
    
    cms.render = function (config, inExtension,outExtension,templateData,file, next) {
        if( inExtension != 'md' && inExtension != 'markdown' )  {
          return next();
        }       

/* still thinking about caching         
        if ( !cms.areObjectsEqual(cms.g_urls,cms.last_urls)  || !cms.areObjectsEqual(cms.g_titles, cms.last_titles) ) {
                console.log("clearing markdown cache");
                
                cms.markdownCache = {};
                cms.last_urls = cms.g_urls;
                cms.last_titles= cms.g_titles;
            }
        
        console.log("Rendering ["+file.fullPath+"]");
*/        
        
        file.content = cms.markdown(file.content, templateData);
        
        var match = null;
        
        if( (match = /^```\s*(.*)\s*$([\s|\S]*?)^```\s*$/img.exec(file.content)) != null ) { 
            do {
                var piggybacks = {};
                var lang = RegExp.$1;
                if( lang == "" ) {
                    lang = "text"
                }
                var src = RegExp.$2;
                var key = "«--CODE:"+md5(src)+"--»";
                
                file.content = file.content.replace( match[0], key );
            
                var pb_match = null;
                while((pb_match = /«(.*?)«(.*?)»/ig.exec(src)) != null)  {
                    var a_code = RegExp.$1;
                    var a_href = RegExp.$2;
                    var hash = "X"+md5(a_href);
                    src = src.replace(pb_match[0] , "«"+a_code+"»"+hash+"»" );
                    piggybacks[hash] = a_href;
                }
                setTimeout( function(file,key, lang, src, next, piggybacks,templateData) { return function() { return completeHighlight( file,key, lang, src, next, piggybacks,templateData);} }(file,key, lang, src, next, piggybacks,templateData) , 10);
            } while( (match = /^```\s*(.*)\s*$([\s|\S]*?)^```\s*$/img.exec(file.content)) != null )
        } else { 
            // we did this up front.
            // file.content = cms.markdown(file.content, templateData);
            next();
        }
    };
  
    function completeHighlight(file, key, language, src, next, piggybacks, templateData) {
        var text = '';
        
        if( undefined != cms.highlightCache[key] ) {
            // we've got the result from this cached in memory from a previous run
            // let's just skip to the end :)
            text = cms.highlightCache[key];
            
            return reallyCompleteHighlight(file, key, text, next, piggybacks,templateData);
        }
        
        var req = http.request({ host: "pygments.appspot.com", port: 80, path: '', method: 'POST' }, function(response) {
            response.setEncoding('utf8');
            
            response.on('data', function (chunk) {
                text += chunk;
            });
            
            response.on('end', function() {
                text = "\n<p>\n"+text+"\n<p>\n";
                cms.highlightCache[key] = text; //save for next time...
                return reallyCompleteHighlight(file, key, text, next, piggybacks,templateData);
            });
        });
        req.write(querystring.stringify({lang:language, code:src}));
        req.end();
    }
  
    function reallyCompleteHighlight(file, key, text, next, piggybacks, templateData) {
        // find our piggybacks in text and restore them as links
        for(ndx in piggybacks) { 
            text = text.replace( new RegExp("«([\\s|\\S]*?)».*?"+ndx+".*?»", "ig" ), '<a class="lnk" href="'+piggybacks[ndx]+'">$1</a>' );
        }
                
        file.content = file.content.replace(key , text );
        if( /«--CODE:.{32}--»/.exec(file.content) == null) {
            
            /*
            // this would cache the results, but perhaps not so wise.
            
            if( cms.highlightCache[file.content] == undefined ) { 
                cms.highlightCache[file.content] = cms.markdown(file.content, templateData);
            }
            
            file.content = cms.highlightCache[file.content];
            
            */
            // we did this up front.
            // file.content = cms.markdown(file.content, templateData);
            next();
        }
    }
    
    cms.generateBefore = function(config, next) {
      next();
    };
    cms.generateAfter = function(config, next) {
      next();
    };
    
    cms.cleanBefore = function(config, next) {
      next();
    };
    cms.cleanAfter = function(config, next) {
      next();
    };
    
    cms.parseBefore = function(config, next) {
      // console.log("parseBefore");
        next();
    };
    cms.parseAfter = function(config, next) {
        next();
        //console.log("parseAfter");
    };
    
    cms.renderBefore = function(config, templateData, next) {
        // console.log("RENDER_BEFORE");
        cms.scanFiles(config, templateData, next );
    };
    
    
    cms.scanFiles= function(config, templateData, next ) {
        // console.log("=== Scanning for references");
        
        var docs = enumerabl.create( templateData.documents );
            
        docs.each( function(doc) { 
            // set the date on the doc to the date in the filename if it exists
            var d =/^(\d{4})-(\d{1,2})-(\d{1,2})/.exec(doc.filename);
            if( d ) {
                doc.date = new Date( RegExp.$1, --(RegExp.$2), RegExp.$3);
            }   
            
            // set the document order to zero if not specified
            doc.order = doc.order || 0;
            
            // add the docid and title to the global urls and titles 
            if ( doc.docid != undefined ) {
                cms.g_urls[doc.docid] = doc.url;
                cms.g_titles[doc.docid] = doc.title;
            }
        });
        
        var recurseFolder = function(dir, done) {
            var results = [];
          
            fs.readdir(dir, function(err, list) {
                if (err) return done(err);
                var pending = list.length;
                list.forEach(function(file) {
                    file = dir + '/' + file;
                    fs.stat(file, function(err, stat) {
                        if (stat && stat.isDirectory()) {
                            recurseFolder(file, function(err, res) {
                                for(ndx in res ) {
                                    results[ndx] = res[ndx];
                                }
                                if (!--pending) {
                                    done(null, results);
                                }
                            });
                        } else {
                            results[path.basename(file)] = path.normalize(file);
                            if (!--pending) { 
                                done(null, results);
                            }
                        }
                    });
                });
            });
        };

        var staticPath = config.docpad.config.publicPath ;
        recurseFolder( staticPath , function(n, files) { 
            for(ndx in files) {
                if( cms.imgs.where( function(each) { return each == path.extname(ndx); } ).any()) {
                    cms.g_urls[ndx.toLowerCase()] = "/"+path.relative(staticPath, files[ndx] ).replace(/\\/g, "/");
                }
            }
            next();    
        });         
    };
    
    
    cms.renderAfter = function(config, next) {
      next();
    };
    
    cms.writeBefore = function(config, next) {
      next();
    };
    cms.writeAfter = function(config, next) {
        /* still thinking about caching
        
        console.log("writeAfter");
        // snapshot the references for later comparison
        cms.last_urls = cms.g_urls ;
        cms.last_titles = cms.g_titles;
        */
        // clear the reference urls/titles
        cms.g_urls = [];
        cms.g_titles = [];       
        
        if( config.docpad.config.sound == 'true' ) {
            grep  = spawn('cscript', ["//e:jscript","tools\\js.js","Speech.PlaySound('"+config.docpad.config.rootPath+"\\tools\\sound2.wav');"]);
        }

             
            
      next();
    };
    
    cms.serverBefore = function(config, next) {
        // happens once just before the server is started.
      next();
    };
    cms.serverAfter = function(config, next) {
        // happens once just after the server is started.
      next();
    };
    
    cms.areObjectsEqual = function( x, y ) {
        if ( x === y ) return true;
        // if both x and y are null or undefined and exactly the same

        if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false;
        // if they are not strictly equal, they both need to be Objects

        if ( x.constructor !== y.constructor ) return false;
        // they must have the exact same prototype chain, the closest we can do is
        // test there constructor.

        for ( var p in x ) {
            if ( ! x.hasOwnProperty( p ) ) continue;
            // other properties were tested using x.constructor === y.constructor

            if ( ! y.hasOwnProperty( p ) ) return false;
            // allows to compare x[ p ] and y[ p ] when set to undefined

            if ( x[ p ] === y[ p ] ) continue;
            // if they have the same strict value or identity then they are equal

            if ( typeof( x[ p ] ) !== "object" ) return false;
            // Numbers, Strings, Functions, Booleans must be strictly equal

            if ( ! Object.equals( x[ p ],  y[ p ] ) ) return false;
            // Objects and Arrays must be tested recursively
        }

        for ( p in y ) {
            if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) ) return false;
            // allows x[ p ] to be set to undefined
        }
        return true;
  };
    
}
