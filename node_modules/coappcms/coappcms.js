// Since I can't write in coffee-script, I created this in javascript, and 
// just pass the work along to it.

var querystring = require("querystring");
var md5 = require('MD5');
var http = require('http');
var util= require('util');
var enumerabl=require("enumerable"); 
var spawn = require('child_process').spawn;
var ejs= require("ejs");
var gfm = require("github-flavored-markdown");
var fs = require('fs');
var path = require('path');

var cms= {};

if (typeof exports === "object") {
    cms = exports;
    cms.config = null;
    cms.cache = {};
    cms.g_urls = [];
    cms.g_titles = [];     
    cms.imgs = [".jpg", ".gif", ".png", ".JPG", ".GIF", ".PNG" ].enumerable();
        
    cms.setConfig = function( config ) {
        cms.config = config;
    }
    
    /// Our cms.include function acts as a <>.html.md.ejs filter.
    cms.include = function(file, templateData) {
        file = path.join( cms.config.includePath , file );
        if( path.existsSync(file) ) {
            var filecontent = fs.readFileSync(file,encoding='utf8');
            filecontent = ejs.render(filecontent, templateData);
            return cms.markdown(filecontent, templateData);
        }
        return "INCLUDE FAIL: ["+file+"] does not exist";
    };
    
    cms.markdown = function( filecontent, templateData ) {
        // handle my custom anchors
        // [text](!id)
        if( templateData != undefined &&  templateData.document != undefined && templateData.document.docid != undefined ) {
            var match = null;
            var rx = /\[(.*?)\]\(\!(.*?)\)/g;
            var x =0;
            while( (match = rx.exec(filecontent) ) != null ) {
                // match[2]
                cms.g_urls[templateData.document.docid + "#" +match[2]] = templateData.document.url + "#" +match[2];
                cms.g_titles[templateData.document.docid + "#" +match[2]] = match[1] +" in " + templateData.document.title;
                // console.log(match[0]+"+" + x++ );
            }
        }
        filecontent = filecontent.replace(/\[(.*?)\]\(\!(.*?)\)/gi , '<a id="$2" href="#$2">$1</a>' );
        
        // handle my custom image inserts
        // @[text](url)
        filecontent = filecontent.replace(/@\[(.*?)\]\((.*?)\)/gi , function(m0,m1,m2) {
            return '<span class="scrollcontainer">!['+m1+']('+((cms.g_urls[m2] == undefined) ? m2 : cms.g_urls[m2]) +')</span>';
        } );
        
        // handle my custom video inserts
        // %[width,height,posterimageurl,mp4url,webmurl]
        filecontent = filecontent.replace(/%\[\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*\]/gi, function(p0,p1,p2,p3,p4,p5) {
            return '\n<div class="embeddedvideo">\n<video width="100%" height="100%" poster="'+((cms.g_urls[p3] == undefined) ? p3 : cms.g_urls[p3])+'" controls="controls" preload="none" style="width:100%; height:100%;">' +
            '    <source type="video/mp4" src="'+p4+'" />' +
            '    <source type="video/webm" src="'+p5+'" />' +         
            '    <object width="'+p1+'" height="'+p2+'" type="application/x-shockwave-flash" data="/scripts/flashmediaelement.swf">' + 
            '        <param name="movie" value="/scripts/flashmediaelement.swf" />' +
            '        <param name="flashvars" value="controls=true&file='+p4+'" />' + 
            '        <img src="'+((cms.g_urls[p3] == undefined) ? p3 : cms.g_urls[p3])+'" width="'+p1+'" height="'+p2+'" title="No video playback capabilities" />' + //Image as a last resort 
            '    </object>'+ 
            '</video>\n</div>\n'
        });
        
        filecontent = gfm.parse( filecontent, undefined, cms.g_urls, cms.g_titles );
        
        return filecontent.replace(" @", "@");
    }
    
    cms.render = function (config, inExtension,outExtension,templateData,file, next) {
        if( inExtension != 'md' && inExtension != 'markdown' )  {
          return next();
        }
        
        var piggybacks = {};
        var match = null;
        
        if( (match = /^```\s*(.*)\s*$([\s|\S]*?)^```$/img.exec(file.content)) != null ) { 
            do {
                var lang = RegExp.$1;
                var src = RegExp.$2;
                var key = "«--CODE:"+md5(src)+"--»";
                
                file.content = file.content.replace( match[0], key );
            
                var pb_match = null;
                while((pb_match = /«(.*?)«(.*?)»/ig.exec(src)) != null)  {
                    var a_code = RegExp.$1;
                    var a_href = RegExp.$2;
                    var hash = md5(a_href);
                    src = src.replace(pb_match[0] , "«"+a_code+"»"+hash+"»" );
                    piggybacks[hash] = a_href;
                }
                setTimeout( function(file,key, lang, src, next, piggybacks,templateData) { return function() { return completeHighlight( file,key, lang, src, next, piggybacks,templateData);} }(file,key, lang, src, next, piggybacks,templateData) , 10);
            } while( (match = /^```\s*(.*)\s*$([\s|\S]*?)^```$/img.exec(file.content)) != null )
        } else { 
            file.content = cms.markdown(file.content, templateData);
            next();
        }
    };
  
    function completeHighlight(file, key, language, src, next, piggybacks, templateData) {
        var text = '';
        
        if( undefined != cms.cache[key] ) {
            // we've got the result from this cached in memory from a previous run
            // let's just skip to the end :)
            text = cms.cache[key];
            
            return reallyCompleteHighlight(file, key, text, next, piggybacks,templateData);
        }
        
        var req = http.request({ host: "pygments.appspot.com", port: 80, path: '', method: 'POST' }, function(response) {
            response.setEncoding('utf8');
            
            response.on('data', function (chunk) {
                text += chunk;
            });
            
            response.on('end', function() {
                cms.cache[key] = text;
                return reallyCompleteHighlight(file, key, text, next, piggybacks,templateData);
            });
        });
        req.write(querystring.stringify({lang:language, code:src}));
        req.end();
    }
  
    function reallyCompleteHighlight(file, key, text, next, piggybacks, templateData) {
        // find our piggybacks in text and restore them as links
        for(ndx in piggybacks) { 
            text = text.replace( new RegExp("«([\\s|\\S]*?)»"+ndx+"»", "ig" ), '<a class="lnk" href="'+piggybacks[ndx]+'">$1</a>' );
        }
                
        file.content = file.content.replace(key , text );
        if( /«--CODE:.{32}--»/.exec(file.content) == null) {
            
            /*
            // this would cache the results, but perhaps not so wise.
            
            if( cms.cache[file.content] == undefined ) { 
                cms.cache[file.content] = cms.markdown(file.content, templateData);
            }
            
            file.content = cms.cache[file.content];
            
            */
            
            file.content = cms.markdown(file.content, templateData);
            next();
        }
    }
    
    cms.generateBefore = function(config, next) {
      next();
    };
    cms.generateAfter = function(config, next) {
      next();
    };
    
    cms.cleanBefore = function(config, next) {
      next();
    };
    cms.cleanAfter = function(config, next) {
      next();
    };
    
    cms.parseBefore = function(config, next) {
      next();
    };
    cms.parseAfter = function(config, next) {
      next();
    };
    
    //cms.xxx = 0;
    
    cms.renderBefore = function(config, templateData, next) {
        //console.log("RENDER_BEFORE");
        var docs = enumerabl.create( templateData.documents );
        
            
        docs.each( function(doc) { 
            // set the date on the doc to the date in the filename if it exists
            var d =/^(\d{4})-(\d{1,2})-(\d{1,2})/.exec(doc.filename);
            if( d ) {
                doc.date = new Date( RegExp.$1, --(RegExp.$2), RegExp.$3);
            }   
            
            // set the document order to zero if not specified
            doc.order = doc.order || 0;
            
            
            // add the docid and title to the global urls and titles 
            if ( doc.docid != undefined ) {
                cms.g_urls[doc.docid] = doc.url;
                cms.g_titles[doc.docid] = doc.title;
            }
            
        });
        
        var recurseFolder = function(dir, done) {
            var results = [];
          
            fs.readdir(dir, function(err, list) {
                if (err) return done(err);
                var pending = list.length;
                list.forEach(function(file) {
                    file = dir + '/' + file;
                    fs.stat(file, function(err, stat) {
                        if (stat && stat.isDirectory()) {
                            recurseFolder(file, function(err, res) {
                                for(ndx in res ) {
                                    results[ndx] = res[ndx];
                                }
                                if (!--pending) {
                                    done(null, results);
                                }
                            });
                        } else {
                            results[path.basename(file)] = path.normalize(file);
                            if (!--pending) { 
                                done(null, results);
                            }
                        }
                    });
                });
            });
        };

        var staticPath = config.docpad.config.publicPath ;
        recurseFolder( staticPath , function(n, files) { 
            for(ndx in files) {
                if( cms.imgs.where( function(each) { return each == path.extname(ndx); } ).any()) {
                    cms.g_urls[ndx.toLowerCase()] = "/"+path.relative(staticPath, files[ndx] ).replace(/\\/g, "/");
                    //console.log( ndx.toLowerCase() + " => " + "/"+path.relative(staticPath, files[ndx] ).replace(/\\/g, "/"));
                }
            }
            
            next();    
        }); 
        
        
    };
    cms.renderAfter = function(config, next) {
      next();
    };
    
    cms.writeBefore = function(config, next) {
      next();
    };
    cms.writeAfter = function(config, next) {
        if( config.docpad.config.sound == 'true' ) {
            grep  = spawn('cscript', ["//e:jscript","tools\\js.js","Speech.PlaySound('"+config.docpad.config.rootPath+"\\tools\\sound2.wav');"]);
        }
        
        // clear the reference urls/titles
        cms.g_urls = [];
        cms.g_titles = [];            
            
      next();
    };
    
    cms.serverBefore = function(config, next) {
        // happens once just before the server is started.
      next();
    };
    cms.serverAfter = function(config, next) {
        // happens once just after the server is started.
      next();
    };
}
