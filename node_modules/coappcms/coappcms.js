// Since I can't write in coffee-script, I created this in javascript, and 
// just pass the work along to it.

var querystring = require("querystring");
var md5 = require('MD5');
var http = require('http');
var util= require('util');
var enumerabl=require("enumerable"); 
var spawn = require('child_process').spawn;
var ejs= require("ejs");
var gfm = require("github-flavored-markdown");
var fs = require('fs');
var path = require('path');

var cms= {};

if (typeof exports === "object") {
    cms = exports;
    cms.config = null;
    cms.highlightCache = {};
    cms.counter = 0;
/*        
    cms.markdownCache = {};
    cms.last_urls = [];
    cms.last_titles = [];         
*/        
    cms.g_urls = [];
    cms.g_titles = [];     
    cms.imgs = [".jpg", ".gif", ".png", ".JPG", ".GIF", ".PNG" ].enumerable();

    String.prototype.Format = function () {
        var args = (arguments.length == 1 && typeof (arguments[0]) == "object") ? arguments[0] : arguments;

        return this.replace(/{(.*?)}/g, function (match, param) {
            var v = args[param];

            if (!IsNullOrUndefined(v)) {
                return v;
            }

            try {
                return eval(param);
            } catch (err) {
                for (var i = 0; i < args.length; i++) {
                    v = args[i][param];
                    if (!IsNullOrUndefined(v)) {
                        return v;
                    }
                }
            }
            return match;
        });
    };

    //+ Jonas Raoni Soares Silva
    //@ http://jsfromhell.com/string/pad [rev. #1]
    /// Returns the string with a substring padded on the left, right or both sides.
    /// length: amount of characters that the string must have
    /// substring: string that will be concatenated
    /// type: specifies the side where the concatenation will happen, where: 0 = left, 1 = right and 2 = both sides
    String.prototype.pad = function (l, s, t) {
        return s || (s = " "), (l -= this.length) > 0 ? (s = new Array(Math.ceil(l / s.length)
        + 1).join(s)).substr(0, t = !t ? l : t == 1 ? 0 : Math.ceil(l / 2))
        + this + s.substr(0, l - t) : this;
    };

    String.prototype.Trim = function () {
        return (this || "").replace(/^\s+|\s+$/g, "");
    };

    function IsNullOrEmpty(str) {
        return str === null || str === "" || str == undefined;
    };

    function IsNullOrUndefined(str) {
        return str === null || str == undefined;
    };

    cms.setConfig = function(config) {
        cms.config = config;
    };
    
    /// Our cms.include function acts as a .html.md.ejs filter.
    cms.include = function(file, templateData) {
        file = path.join( cms.config.includePath , file );
        if( path.existsSync(file) ) {
            var filecontent = fs.readFileSync(file,encoding='utf8');
            filecontent = ejs.render(filecontent, templateData);
            return cms.markdown(filecontent, templateData);
        }
        return "INCLUDE FAIL: ["+file+"] does not exist";
    };

    cms.markdown = function (filecontent, templateData) {
        /* still thinking.
        var hash = md5(filecontent);
        if( undefined != cms.markdownCache[hash] ) {
        return cms.markdownCache[hash];
        }
        */
        filecontent = filecontent.replace(/@github\.com/ig, "-at-github.com");

        // handle my custom anchors
        // [text](!id)
        if (templateData != undefined && templateData.document != undefined && templateData.document.docid != undefined) {
            var match = null;
            var rx = /\[(.*?)\]\(\!(.*?)\)/g;

            while ((match = rx.exec(filecontent)) != null) {
                // match[2]
                cms.g_urls[templateData.document.docid + "#" + match[2]] = templateData.document.url + "#" + match[2];
                cms.g_titles[templateData.document.docid + "#" + match[2]] = match[1] + " in " + templateData.document.title;
            }
        }
        filecontent = filecontent.replace(/\[(.*?)\]\(\!(.*?)\)/gi, '<a id="$2" href="#$2">$1</a>');

        // handle my custom image inserts
        // @[text](url)
        filecontent = filecontent.replace(/@\[(.*?)\]\((.*?)\)/gi, function (m0, m1, m2) {
            return '<span class="scrollcontainer">![' + m1 + '](' + ((cms.g_urls[m2] == undefined) ? m2 : cms.g_urls[m2]) + ')</span>';
        });

        // handle my custom video inserts
        // %[width,height,posterimageurl,mp4url,webmurl]
        filecontent = filecontent.replace(/%\[\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*,\s*(.*)\s*\]/gi, function (p0, p1, p2, p3, p4, p5) {
            return '\n<div class="embeddedvideo">\n<video width="100%" height="100%" poster="' + ((cms.g_urls[p3] == undefined) ? p3 : cms.g_urls[p3]) + '" controls="controls" preload="none" style="width:100%; height:100%;">' +
                '    <source type="video/mp4" src="' + p4 + '" />' +
                    '    <source type="video/webm" src="' + p5 + '" />' +
                        '    <object width="' + p1 + '" height="' + p2 + '" type="application/x-shockwave-flash" data="/scripts/flashmediaelement.swf">' +
                            '        <param name="movie" value="/scripts/flashmediaelement.swf" />' +
                                '        <param name="flashvars" value="controls=true&file=' + p4 + '" />' +
                                    '        <img src="' + ((cms.g_urls[p3] == undefined) ? p3 : cms.g_urls[p3]) + '" width="' + p1 + '" height="' + p2 + '" title="No video playback capabilities" />' + //Image as a last resort 
                                        '    </object>' +
                                            '</video>\n</div>\n';
        });

        filecontent = gfm.parse(filecontent, undefined, cms.g_urls, cms.g_titles);

        // handle my table formatter (after regular markdown)
        // |header1|header2|header3|
        // |row1text1|row1text3|row1text3|

        // <p>|Variable|Description|<br />|${apps}|coapp root directory (typically <code>c:\apps</code>)|</p>
        filecontent = filecontent.replace(/<p>(\|.*\|)<\/p>/g, function (match1, table) {
            table = table.replace(/\|<br \/>\|/g, "|\n|");
            var rows = table.split("\n");
            var result = '';
            // first row is always the header
            result += '<p>\n    <table class="zebra-striped condensed-table" style="width:;" ><thead><tr>';
            var cells = rows[0].split('|');
            for (var c = 0; c < cells.length; c++) {
                result += '<th>{0}</th>'.Format(cells[c]);
            }
            result += "</tr></thead>\n    <tbody>";

            for (var i = 1; i < rows.length; i++) {
                result += '    <tr>';
                cells = rows[i].split('|');
                for (c = 0; c < cells.length; c++) {
                    result += '<td>{0}</td>'.Format(cells[c]);
                }
                result += '</tr>\n';
            }

            result += "    </tbody></table>\n</p>";
            return result;
        });

        // return cms.markdownCache[hash] = filecontent.replace(/ /ig, "");
        return filecontent.replace(/ /ig, "").replace(/-at-github\.com/ig, "@github.com");
    };

    cms.render = function (config, inExtension, outExtension, templateData, file, next) {
        if (inExtension != 'md' && inExtension != 'markdown') {
            return next();
        }

        /* still thinking about caching         
        if ( !cms.areObjectsEqual(cms.g_urls,cms.last_urls)  || !cms.areObjectsEqual(cms.g_titles, cms.last_titles) ) {
        console.log("clearing markdown cache");
                
        cms.markdownCache = {};
        cms.last_urls = cms.g_urls;
        cms.last_titles= cms.g_titles;
        }
        
        console.log("Rendering ["+file.fullPath+"]");
        */

        file.content = cms.markdown(file.content, templateData);
        var done = next;
        
        file.content = file.content.replace( /^```\s*(.*)\s*$([\s|\S]*?)^```\s*$/img , function(match, language, src ) {
            language = IsNullOrEmpty( language ) ? "text" : language;
            var piggybacks = {};
            var key = "«--CODE:" + md5(src) + "--»";
                
            src = src.replace( /«([^«]*?)«([^»]*?)»/ig, function(pb_match, a_code, a_href) {
                var hash = "X" + md5(a_href);
                piggybacks[hash] = a_href
                return "«{0}»{1}»".Format(a_code,hash)
            });   
            
            if( undefined === cms.highlightCache[key] ) {
                next = function(){}; // we'll handle this when we're really done.
                var text = '';
                var req = http.request({ host: "pygments.appspot.com", port: 80, path: '', method: 'POST' }, function(response) {
                    response.setEncoding('utf8');
                    response.on('data', function (chunk) {
                        text += chunk;
                    });
            
                    response.on('end', function() {
                        text = "\n<p>\n"+text+"\n<p>\n";
                        cms.highlightCache[key] = text; //save for next time...
                        text = transformHighightText(text,piggybacks);
                        file.content = file.content.replace(key , text );
                        setTimeout( function() {
                            if( /«--CODE:.{32}--»/.exec(file.content) == null) {
                                done();    
                            }
                        },10);
                    });
                });
                req.write(querystring.stringify({lang:language, code:src}));
                req.end();   
                return key;                
            }

            // we didn't take the trip, just return the fancy text.
            return transformHighightText(cms.highlightCache[key],piggybacks);
        });
        
        if( /«--CODE:.{32}--»/.exec(file.content) == null) {
            next();    
        }
    };
  
    function transformHighightText(text,piggybacks) {
        // first, fix those pesky err classes for out smuggled character
        text = text.replace(/\<span class="err"\>(.)\<\/span\>/g, "$1");

        // then run through the list of piggybacks
        for (var ndx in piggybacks) {
           text = text.replace( new RegExp("«([^»^«]*?)»[^»^«]*?"+ndx+"[^»^«]*?»", "ig" ), '<a class="lnk" href="'+piggybacks[ndx]+'">$1</a>' );
        }

		text = text.replace( /https_/ig , "https" );
		text = text.replace( /http_/ig , "http" );
		
        // whacko manual style override: change comment to specific style:
        // takes <span class="cm">/*(style):(content-to-restyle)*/</span>
        text = text.replace(/\<span class="cm"\>.*?\((.*?)\):\((.*?)\).*?\<\/span\>/ig, function (match, style, txt) {
            return '<span class="{0}">{1}</span>'.Format(style, txt);
        });

        return text;  
    }
   
    cms.generateBefore = function(config, next) {
      next();
    };
    cms.generateAfter = function(config, next) {
      next();
    };
    
    cms.cleanBefore = function(config, next) {
      next();
    };
    cms.cleanAfter = function(config, next) {
      next();
    };
    
    cms.parseBefore = function(config, next) {
      // console.log("parseBefore");
        next();
    };
    cms.parseAfter = function(config, next) {
        next();
        //console.log("parseAfter");
    };
    
    cms.renderBefore = function(config, templateData, next) {
        // console.log("RENDER_BEFORE");
        cms.scanFiles(config, templateData, next );
    };
    
    
    cms.scanFiles= function(config, templateData, next ) {
        // console.log("=== Scanning for references");
        
        var docs = enumerabl.create( templateData.documents );
            
        docs.each( function(doc) { 
            // set the date on the doc to the date in the filename if it exists
            var d =/^(\d{4})-(\d{1,2})-(\d{1,2})/.exec(doc.filename);
            if( d ) {
                doc.date = new Date( RegExp.$1, --(RegExp.$2), RegExp.$3);
            }   
            
            // set the document order to zero if not specified
            doc.order = doc.order || 0;
            
            // add the docid and title to the global urls and titles 
            if ( doc.docid != undefined ) {
                cms.g_urls[doc.docid] = doc.url;
                cms.g_titles[doc.docid] = doc.title;
            }
        });
        
        var recurseFolder = function(dir, done) {
            var results = [];
          
            fs.readdir(dir, function(err, list) {
                if (err) return done(err);
                var pending = list.length;
                list.forEach(function(file) {
                    file = dir + '/' + file;
                    fs.stat(file, function(err, stat) {
                        if (stat && stat.isDirectory()) {
                            recurseFolder(file, function(err, res) {
                                for(var ndx in res ) {
                                    results[ndx] = res[ndx];
                                }
                                if (!--pending) {
                                    done(null, results);
                                }
                            });
                        } else {
                            results[path.basename(file)] = path.normalize(file);
                            if (!--pending) { 
                                done(null, results);
                            }
                        }
                    });
                });
            });
        };

        var staticPath = config.docpad.config.publicPath ;
        recurseFolder( staticPath , function(n, files) { 
            for(var ndx in files) {
                if( cms.imgs.where( function(each) { return each == path.extname(ndx); } ).any()) {
                    cms.g_urls[ndx.toLowerCase()] = "/"+path.relative(staticPath, files[ndx] ).replace(/\\/g, "/");
                }
            }
            next();    
        });         
    };
    
    
    cms.renderAfter = function(config, next) {
      next();
    };
    
    cms.writeBefore = function(config, next) {
      next();
    };
    cms.writeAfter = function(config, next) {
        /* still thinking about caching
        
        console.log("writeAfter");
        // snapshot the references for later comparison
        cms.last_urls = cms.g_urls ;
        cms.last_titles = cms.g_titles;
        */
        // clear the reference urls/titles
        cms.g_urls = [];
        cms.g_titles = [];       
        
        if( config.docpad.config.sound == 'true' ) {
            var proc = spawn('cscript', ["//e:jscript","tools\\js.js","Speech.PlaySound('"+config.docpad.config.rootPath+"\\tools\\sound2.wav');"]);
        }

             
            
      next();
    };
    
    cms.serverBefore = function(config, next) {
        // happens once just before the server is started.
      next();
    };
    cms.serverAfter = function(config, next) {
        // happens once just after the server is started.
      next();
    };
    
    cms.areObjectsEqual = function( x, y ) {
        if ( x === y ) return true;
        // if both x and y are null or undefined and exactly the same

        if ( ! ( x instanceof Object ) || ! ( y instanceof Object ) ) return false;
        // if they are not strictly equal, they both need to be Objects

        if ( x.constructor !== y.constructor ) return false;
        // they must have the exact same prototype chain, the closest we can do is
        // test there constructor.

        for ( var p in x ) {
            if ( ! x.hasOwnProperty( p ) ) continue;
            // other properties were tested using x.constructor === y.constructor

            if ( ! y.hasOwnProperty( p ) ) return false;
            // allows to compare x[ p ] and y[ p ] when set to undefined

            if ( x[ p ] === y[ p ] ) continue;
            // if they have the same strict value or identity then they are equal

            if ( typeof( x[ p ] ) !== "object" ) return false;
            // Numbers, Strings, Functions, Booleans must be strictly equal

            if ( ! Object.equals( x[ p ],  y[ p ] ) ) return false;
            // Objects and Arrays must be tested recursively
        }

        for ( p in y ) {
            if ( y.hasOwnProperty( p ) && ! x.hasOwnProperty( p ) ) return false;
            // allows x[ p ] to be set to undefined
        }
        return true;
  };
    
}
